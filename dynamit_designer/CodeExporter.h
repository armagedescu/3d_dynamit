#pragma once

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commdlg.h>
#include <string>
#include <sstream>
#include <iomanip>
#include <fstream>

#include "ShapeManager.h"

class CodeExporter
{
public:
    enum class ExportMode
    {
        GeometryOnly,           // Just the builder code generating geometry
        WithDynamitSetup,       // Builder + Dynamit renderer setup
        StandaloneApplication   // Complete application with window and render loop
    };

    // Generate C++ code from shape configuration
    static std::wstring generateCppCode(const ShapeConfig& config, ExportMode mode = ExportMode::WithDynamitSetup, bool includeNormals = false)
    {
        switch (mode)
        {
        case ExportMode::GeometryOnly:
            return generateGeometryOnly(config);
        case ExportMode::WithDynamitSetup:
            return generateWithDynamitSetup(config, includeNormals);
        case ExportMode::StandaloneApplication:
            return generateStandaloneApp(config, includeNormals);
        default:
            return generateWithDynamitSetup(config, includeNormals);
        }
    }

    // Copy text to Windows clipboard
    static bool copyToClipboard(const std::wstring& text)
    {
        if (!OpenClipboard(nullptr))
            return false;

        EmptyClipboard();

        // Allocate global memory for the text
        size_t size = (text.length() + 1) * sizeof(wchar_t);
        HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, size);
        if (!hMem)
        {
            CloseClipboard();
            return false;
        }

        // Copy text to global memory
        wchar_t* pMem = static_cast<wchar_t*>(GlobalLock(hMem));
        if (pMem)
        {
            wcscpy_s(pMem, text.length() + 1, text.c_str());
            GlobalUnlock(hMem);
        }

        // Set clipboard data
        SetClipboardData(CF_UNICODETEXT, hMem);
        CloseClipboard();

        return true;
    }

    // Save code to file with save dialog
    static bool saveToFile(HWND parent, const std::wstring& code)
    {
        wchar_t filename[MAX_PATH] = L"shape.cpp";

        OPENFILENAMEW ofn = {};
        ofn.lStructSize = sizeof(OPENFILENAMEW);
        ofn.hwndOwner = parent;
        ofn.lpstrFilter = L"C++ Source Files (*.cpp)\0*.cpp\0All Files (*.*)\0*.*\0";
        ofn.lpstrFile = filename;
        ofn.nMaxFile = MAX_PATH;
        ofn.lpstrDefExt = L"cpp";
        ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
        ofn.lpstrTitle = L"Save C++ Code";

        if (!GetSaveFileNameW(&ofn))
            return false;

        // Convert wide string to UTF-8 for file writing
        std::string utf8Code = wstringToUtf8(code);

        // Write to file
        std::ofstream file(filename, std::ios::out | std::ios::binary);
        if (!file.is_open())
        {
            MessageBoxW(parent, L"Failed to create file", L"Error", MB_OK | MB_ICONERROR);
            return false;
        }

        // Write UTF-8 BOM (optional, but helps editors detect encoding)
        const unsigned char bom[] = { 0xEF, 0xBB, 0xBF };
        file.write(reinterpret_cast<const char*>(bom), sizeof(bom));

        file.write(utf8Code.c_str(), utf8Code.length());
        file.close();

        return true;
    }

private:
    // Generate geometry building code only
    static std::wstring generateGeometryOnly(const ShapeConfig& config)
    {
        std::wostringstream code;

        code << L"// Generated by Dynamit Designer - Geometry Only\n";
        code << L"// Shape: " << stringToWstring(config.name) << L"\n\n";

        code << L"#define _USE_MATH_DEFINES\n";
        code << L"#include <cmath>\n";
        code << L"#include <vector>\n";
        code << L"#include <cstdint>\n";
        code << L"#include <builders.h>\n\n";

        code << L"using namespace dynamit::builders;\n\n";

        std::wstring funcName = sanitizeIdentifier(stringToWstring(config.name));
        code << L"void build" << funcName << L"()\n";
        code << L"{\n";

        generateBuilderCode(code, config);

        code << L"    std::vector<float> verts, norms, colors;\n";
        code << L"    std::vector<uint32_t> indices;\n\n";

        if (config.type == ShapeConfig::Type::Cone)
            code << L"    builder.buildConeIndexedWithColor(verts, norms, colors, indices);\n";
        else
            code << L"    builder.buildCylinderIndexedWithColor(verts, norms, colors, indices);\n";

        code << L"}\n";

        return code.str();
    }

    // Generate builder code + Dynamit setup
    static std::wstring generateWithDynamitSetup(const ShapeConfig& config, bool includeNormals)
    {
        std::wostringstream code;

        std::wstring funcName = sanitizeIdentifier(stringToWstring(config.name));

        code << L"// Generated by Dynamit Designer - With Dynamit Setup\n";
        code << L"// Shape: " << stringToWstring(config.name) << L"\n\n";

        code << L"#define _USE_MATH_DEFINES\n";
        code << L"#include <cmath>\n";
        code << L"#include <vector>\n";
        code << L"#include <cstdint>\n";
        code << L"#include <array>\n";
        code << L"#include <builders.h>\n";
        code << L"#include <Dynamit.h>\n\n";

        code << L"using namespace dynamit;\n";
        code << L"using namespace dynamit::builders;\n\n";

        code << L"void build" << funcName << L"()\n";
        code << L"{\n";

        generateBuilderCode(code, config);

        code << L"    std::vector<float> verts, norms, colors;\n";
        code << L"    std::vector<uint32_t> indices;\n\n";

        if (config.type == ShapeConfig::Type::Cone)
            code << L"    builder.buildConeIndexedWithColor(verts, norms, colors, indices);\n";
        else
            code << L"    builder.buildCylinderIndexedWithColor(verts, norms, colors, indices);\n";

        code << L"\n    // Setup Dynamit renderer with auto-generated shaders\n";
        code << L"    Dynamit renderer;\n";
        code << L"    renderer.withVertices3d(verts)\n";
        code << L"            .withNormals3d(norms)\n";
        code << L"            .withColors4d(colors)\n";
        code << L"            .withIndices(indices)\n";
        code << L"            .withConstLightDirection({ -0.577f, -0.577f, 0.577f })\n";
        code << L"            .withTransformMatrix4f(\"transformMatrix\");\n\n";

        if (includeNormals)
        {
            code << L"    // Create normals visualizer for debugging\n";
            code << L"    auto normalsHighlighter = renderer.createNormalsHighlighter(0.05f);\n";
            code << L"    normalsHighlighter->build(verts, norms);\n\n";
        }

        code << L"    // In your render loop:\n";
        code << L"    // 1. Calculate MVP matrix (Model-View-Projection)\n";
        code << L"    //    std::array<float, 16> mvp = calculateMVP();\n";
        code << L"    // 2. Set transform matrix\n";
        code << L"    //    renderer.transformMatrix4f(mvp);\n";
        code << L"    // 3. Draw the shape\n";
        code << L"    //    renderer.drawTrianglesIndexed();\n";

        if (includeNormals)
        {
            code << L"    // 4. Draw normals\n";
            code << L"    //    normalsHighlighter->draw(mvp);\n";
        }

        code << L"}\n";

        return code.str();
    }

    // Generate complete standalone application
    static std::wstring generateStandaloneApp(const ShapeConfig& config, bool includeNormals)
    {
        std::wostringstream code;

        code << L"// Generated by Dynamit Designer - Standalone Application\n";
        code << L"// Shape: " << stringToWstring(config.name) << L"\n";
        code << L"// Controls: WASD to move, mouse to look, ESC to exit";
        if (includeNormals)
            code << L", N to toggle normals";
        code << L"\n\n";

        code << L"#define _USE_MATH_DEFINES\n";
        code << L"#include <cmath>\n";
        code << L"#include <vector>\n";
        code << L"#include <cstdint>\n";
        code << L"#include <array>\n";
        code << L"#include <memory>\n\n";

        code << L"#include <GL/glew.h>\n";
        code << L"#include <GLFW/glfw3.h>\n";
        code << L"#include <glm/glm.hpp>\n";
        code << L"#include <glm/gtc/matrix_transform.hpp>\n";
        code << L"#include <glm/gtc/type_ptr.hpp>\n\n";

        code << L"#include <builders.h>\n";
        code << L"#include <Dynamit.h>\n";
        code << L"#include <Camera.h>\n\n";

        code << L"using namespace dynamit;\n";
        code << L"using namespace dynamit::builders;\n\n";

        code << L"// Global state\n";
        code << L"Camera g_camera(glm::vec3(0.0f, 0.0f, 3.0f));\n";
        code << L"float g_lastX = 512.0f, g_lastY = 384.0f;\n";
        code << L"bool g_firstMouse = true;\n";

        if (includeNormals)
        {
            code << L"bool g_showNormals = false;\n";
        }

        code << L"\n";

        code << L"void mouseCallback(GLFWwindow* window, double xpos, double ypos)\n";
        code << L"{\n";
        code << L"    if (g_firstMouse)\n";
        code << L"    {\n";
        code << L"        g_lastX = static_cast<float>(xpos);\n";
        code << L"        g_lastY = static_cast<float>(ypos);\n";
        code << L"        g_firstMouse = false;\n";
        code << L"    }\n";
        code << L"    float xOffset = static_cast<float>(xpos) - g_lastX;\n";
        code << L"    float yOffset = g_lastY - static_cast<float>(ypos);\n";
        code << L"    g_lastX = static_cast<float>(xpos);\n";
        code << L"    g_lastY = static_cast<float>(ypos);\n";
        code << L"    g_camera.onMouseMove(xOffset, yOffset);\n";
        code << L"}\n\n";

        code << L"void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)\n";
        code << L"{\n";
        code << L"    if (action == GLFW_PRESS)\n";
        code << L"    {\n";
        code << L"        if (key == GLFW_KEY_ESCAPE)\n";
        code << L"            glfwSetWindowShouldClose(window, GLFW_TRUE);\n";

        if (includeNormals)
        {
            code << L"        else if (key == GLFW_KEY_N)\n";
            code << L"            g_showNormals = !g_showNormals;\n";
        }

        code << L"    }\n";
        code << L"}\n\n";

        code << L"void processInput(GLFWwindow* window, float deltaTime)\n";
        code << L"{\n";
        code << L"    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)\n";
        code << L"        g_camera.onKeyboard(Camera::Movement::FORWARD, deltaTime);\n";
        code << L"    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)\n";
        code << L"        g_camera.onKeyboard(Camera::Movement::BACKWARD, deltaTime);\n";
        code << L"    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)\n";
        code << L"        g_camera.onKeyboard(Camera::Movement::LEFT, deltaTime);\n";
        code << L"    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n";
        code << L"        g_camera.onKeyboard(Camera::Movement::RIGHT, deltaTime);\n";
        code << L"}\n\n";

        code << L"int main()\n";
        code << L"{\n";
        code << L"    // Initialize GLFW\n";
        code << L"    if (!glfwInit())\n";
        code << L"        return -1;\n\n";

        code << L"    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n";
        code << L"    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n";
        code << L"    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n";

        code << L"    GLFWwindow* window = glfwCreateWindow(1024, 768, \"" << stringToWstring(config.name) << L"\", nullptr, nullptr);\n";
        code << L"    if (!window)\n";
        code << L"    {\n";
        code << L"        glfwTerminate();\n";
        code << L"        return -1;\n";
        code << L"    }\n\n";

        code << L"    glfwMakeContextCurrent(window);\n";
        code << L"    glfwSetKeyCallback(window, keyCallback);\n";
        code << L"    glfwSetCursorPosCallback(window, mouseCallback);\n";
        code << L"    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n";

        code << L"    // Initialize GLEW\n";
        code << L"    glewExperimental = GL_TRUE;\n";
        code << L"    if (glewInit() != GLEW_OK)\n";
        code << L"        return -1;\n\n";

        code << L"    glEnable(GL_DEPTH_TEST);\n";
        code << L"    glClearColor(0.1f, 0.1f, 0.15f, 1.0f);\n\n";

        code << L"    // Build shape geometry\n";
        generateBuilderCode(code, config);

        code << L"    std::vector<float> verts, norms, colors;\n";
        code << L"    std::vector<uint32_t> indices;\n\n";

        if (config.type == ShapeConfig::Type::Cone)
            code << L"    builder.buildConeIndexedWithColor(verts, norms, colors, indices);\n\n";
        else
            code << L"    builder.buildCylinderIndexedWithColor(verts, norms, colors, indices);\n\n";

        code << L"    // Setup Dynamit renderer\n";
        code << L"    Dynamit renderer;\n";
        code << L"    renderer.withVertices3d(verts)\n";
        code << L"            .withNormals3d(norms)\n";
        code << L"            .withColors4d(colors)\n";
        code << L"            .withIndices(indices)\n";
        code << L"            .withConstLightDirection({ -0.577f, -0.577f, 0.577f })\n";
        code << L"            .withTransformMatrix4f(\"transformMatrix\");\n\n";

        if (includeNormals)
        {
            code << L"    // Create normals highlighter\n";
            code << L"    auto normalsHighlighter = renderer.createNormalsHighlighter(0.05f);\n";
            code << L"    normalsHighlighter->build(verts, norms);\n\n";
        }

        code << L"    // Render loop\n";
        code << L"    float lastFrame = 0.0f;\n";
        code << L"    while (!glfwWindowShouldClose(window))\n";
        code << L"    {\n";
        code << L"        // Delta time\n";
        code << L"        float currentFrame = static_cast<float>(glfwGetTime());\n";
        code << L"        float deltaTime = currentFrame - lastFrame;\n";
        code << L"        lastFrame = currentFrame;\n\n";

        code << L"        // Process input\n";
        code << L"        processInput(window, deltaTime);\n\n";

        code << L"        // Clear\n";
        code << L"        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n";

        code << L"        // Calculate matrices\n";
        code << L"        int width, height;\n";
        code << L"        glfwGetFramebufferSize(window, &width, &height);\n";
        code << L"        glViewport(0, 0, width, height);\n\n";

        code << L"        glm::mat4 projection = glm::perspective(glm::radians(g_camera.zoom),\n";
        code << L"                                                static_cast<float>(width) / static_cast<float>(height),\n";
        code << L"                                                0.1f, 100.0f);\n";
        code << L"        glm::mat4 view = g_camera.view();\n";
        code << L"        glm::mat4 model = glm::mat4(1.0f);\n";

        // Add transforms if non-default
        if (config.posX != 0.0f || config.posY != 0.0f || config.posZ != 0.0f)
        {
            code << L"        model = glm::translate(model, glm::vec3("
                 << formatFloat(config.posX) << L"f, "
                 << formatFloat(config.posY) << L"f, "
                 << formatFloat(config.posZ) << L"f));\n";
        }
        if (config.rotX != 0.0f || config.rotY != 0.0f || config.rotZ != 0.0f)
        {
            if (config.rotX != 0.0f)
                code << L"        model = glm::rotate(model, glm::radians(" << formatFloat(config.rotX) << L"f), glm::vec3(1, 0, 0));\n";
            if (config.rotY != 0.0f)
                code << L"        model = glm::rotate(model, glm::radians(" << formatFloat(config.rotY) << L"f), glm::vec3(0, 1, 0));\n";
            if (config.rotZ != 0.0f)
                code << L"        model = glm::rotate(model, glm::radians(" << formatFloat(config.rotZ) << L"f), glm::vec3(0, 0, 1));\n";
        }
        if (config.scaleX != 1.0f || config.scaleY != 1.0f || config.scaleZ != 1.0f)
        {
            code << L"        model = glm::scale(model, glm::vec3("
                 << formatFloat(config.scaleX) << L"f, "
                 << formatFloat(config.scaleY) << L"f, "
                 << formatFloat(config.scaleZ) << L"f));\n";
        }

        code << L"        glm::mat4 mvp = projection * view * model;\n\n";

        code << L"        std::array<float, 16> mvpArray;\n";
        code << L"        memcpy(mvpArray.data(), glm::value_ptr(mvp), sizeof(float) * 16);\n\n";

        code << L"        // Render shape\n";
        code << L"        renderer.transformMatrix4f(mvpArray);\n";
        code << L"        renderer.drawTrianglesIndexed();\n\n";

        if (includeNormals)
        {
            code << L"        // Render normals if enabled (press N to toggle)\n";
            code << L"        if (g_showNormals)\n";
            code << L"            normalsHighlighter->draw(mvpArray);\n\n";
        }

        code << L"        glfwSwapBuffers(window);\n";
        code << L"        glfwPollEvents();\n";
        code << L"    }\n\n";

        code << L"    glfwTerminate();\n";
        code << L"    return 0;\n";
        code << L"}\n";

        return code.str();
    }

    // Generate builder configuration code (shared by all modes)
    static void generateBuilderCode(std::wostringstream& code, const ShapeConfig& config)
    {
        code << L"    PolarBuilder builder = Builder::polar();\n";
        code << L"    builder.formula(L\"" << escapeWstring(config.formula) << L"\")\n";
        code << L"        .domain(" << formatFloat(config.domainStart) << L"f, " << formatFloat(config.domainEnd) << L"f)\n";
        code << L"        .sectors(" << config.sectors << L")\n";
        code << L"        .slices(" << config.slices << L")\n";
        code << L"        .smooth(" << (config.smooth ? L"true" : L"false") << L")\n";
        code << L"        .turbo(" << (config.turbo ? L"true" : L"false") << L")\n";
        code << L"        .doubleCoated(" << (config.doubleCoated ? L"true" : L"false") << L")\n";
        code << L"        .reversed(" << (config.reversed ? L"true" : L"false") << L")\n";
        code << L"        .color({" << formatFloat(config.outerColor[0]) << L"f, "
                                    << formatFloat(config.outerColor[1]) << L"f, "
                                    << formatFloat(config.outerColor[2]) << L"f, "
                                    << formatFloat(config.outerColor[3]) << L"f},\n";
        code << L"               {" << formatFloat(config.innerColor[0]) << L"f, "
                                    << formatFloat(config.innerColor[1]) << L"f, "
                                    << formatFloat(config.innerColor[2]) << L"f, "
                                    << formatFloat(config.innerColor[3]) << L"f});\n\n";
    }

    // Escape special characters in wide string for C++ code
    static std::wstring escapeWstring(const std::wstring& str)
    {
        std::wostringstream escaped;
        for (wchar_t c : str)
        {
            switch (c)
            {
            case L'\\': escaped << L"\\\\"; break;
            case L'"':  escaped << L"\\\""; break;
            case L'\n': escaped << L"\\n"; break;
            case L'\r': escaped << L"\\r"; break;
            case L'\t': escaped << L"\\t"; break;
            default:    escaped << c; break;
            }
        }
        return escaped.str();
    }

    // Format float with reasonable precision
    static std::wstring formatFloat(float value)
    {
        std::wostringstream ss;
        ss << std::fixed << std::setprecision(4) << value;
        std::wstring result = ss.str();

        // Remove trailing zeros after decimal point
        size_t dotPos = result.find(L'.');
        if (dotPos != std::wstring::npos)
        {
            size_t lastNonZero = result.find_last_not_of(L'0');
            if (lastNonZero != std::wstring::npos && lastNonZero > dotPos)
            {
                result = result.substr(0, lastNonZero + 1);
            }
            // Remove trailing dot
            if (result.back() == L'.')
            {
                result += L'0';
            }
        }
        return result;
    }

    // Convert narrow string to wide string
    static std::wstring stringToWstring(const std::string& str)
    {
        if (str.empty())
            return std::wstring();

        int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), nullptr, 0);
        std::wstring result(size, 0);
        MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), &result[0], size);
        return result;
    }

    // Convert wide string to UTF-8 narrow string
    static std::string wstringToUtf8(const std::wstring& wstr)
    {
        if (wstr.empty())
            return std::string();

        int size = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), nullptr, 0, nullptr, nullptr);
        std::string result(size, 0);
        WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), &result[0], size, nullptr, nullptr);
        return result;
    }

    // Sanitize name for use as C++ identifier (replace invalid chars with underscores)
    static std::wstring sanitizeIdentifier(const std::wstring& name)
    {
        std::wstring result;
        result.reserve(name.length());

        for (size_t i = 0; i < name.length(); ++i)
        {
            wchar_t c = name[i];
            if ((c >= L'a' && c <= L'z') ||
                (c >= L'A' && c <= L'Z') ||
                (c >= L'0' && c <= L'9' && i > 0) ||  // digits allowed except at start
                c == L'_')
            {
                result += c;
            }
            else if (c == L' ' || c == L'-')
            {
                result += L'_';
            }
            // Skip other invalid characters
        }

        // Ensure it doesn't start with a digit
        if (!result.empty() && result[0] >= L'0' && result[0] <= L'9')
        {
            result = L"_" + result;
        }

        // Ensure non-empty
        if (result.empty())
        {
            result = L"Shape";
        }

        return result;
    }
};
