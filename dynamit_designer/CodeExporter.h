#pragma once

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commdlg.h>
#include <string>
#include <sstream>
#include <iomanip>
#include <fstream>

#include "ShapeManager.h"

class CodeExporter
{
public:
    // Generate C++ code from shape configuration
    static std::wstring generateCppCode(const ShapeConfig& config)
    {
        std::wostringstream code;

        // Header comment
        code << L"// Generated by Dynamit Designer\n";
        code << L"// Shape: " << stringToWstring(config.name) << L"\n\n";

        // Includes
        code << L"#define _USE_MATH_DEFINES\n";
        code << L"#include <cmath>\n";
        code << L"#include <vector>\n";
        code << L"#include <cstdint>\n";
        code << L"#include <builders.h>\n\n";

        code << L"using namespace dynamit::builders;\n\n";

        // Function wrapper
        code << L"void build" << stringToWstring(config.name) << L"()\n";
        code << L"{\n";

        // Builder setup
        code << L"    PolarBuilder builder = Builder::polar();\n";
        code << L"    builder.formula(L\"" << escapeWstring(config.formula) << L"\")\n";
        code << L"        .domain(" << formatFloat(config.domainStart) << L"f, " << formatFloat(config.domainEnd) << L"f)\n";
        code << L"        .sectors(" << config.sectors << L")\n";
        code << L"        .slices(" << config.slices << L")\n";
        code << L"        .smooth(" << (config.smooth ? L"true" : L"false") << L")\n";
        code << L"        .turbo(" << (config.turbo ? L"true" : L"false") << L")\n";
        code << L"        .doubleCoated(" << (config.doubleCoated ? L"true" : L"false") << L")\n";
        code << L"        .reversed(" << (config.reversed ? L"true" : L"false") << L")\n";
        code << L"        .color({" << formatFloat(config.outerColor[0]) << L"f, "
                                    << formatFloat(config.outerColor[1]) << L"f, "
                                    << formatFloat(config.outerColor[2]) << L"f, "
                                    << formatFloat(config.outerColor[3]) << L"f},\n";
        code << L"               {" << formatFloat(config.innerColor[0]) << L"f, "
                                    << formatFloat(config.innerColor[1]) << L"f, "
                                    << formatFloat(config.innerColor[2]) << L"f, "
                                    << formatFloat(config.innerColor[3]) << L"f});\n\n";

        // Output buffers
        code << L"    std::vector<float> verts, norms, colors;\n";
        code << L"    std::vector<uint32_t> indices;\n\n";

        // Build call based on shape type
        if (config.type == ShapeConfig::Type::Cone)
        {
            code << L"    builder.buildConeIndexedWithColor(verts, norms, colors, indices);\n";
        }
        else
        {
            code << L"    builder.buildCylinderIndexedWithColor(verts, norms, colors, indices);\n";
        }

        code << L"}\n";

        return code.str();
    }

    // Copy text to Windows clipboard
    static bool copyToClipboard(const std::wstring& text)
    {
        if (!OpenClipboard(nullptr))
            return false;

        EmptyClipboard();

        // Allocate global memory for the text
        size_t size = (text.length() + 1) * sizeof(wchar_t);
        HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, size);
        if (!hMem)
        {
            CloseClipboard();
            return false;
        }

        // Copy text to global memory
        wchar_t* pMem = static_cast<wchar_t*>(GlobalLock(hMem));
        if (pMem)
        {
            wcscpy_s(pMem, text.length() + 1, text.c_str());
            GlobalUnlock(hMem);
        }

        // Set clipboard data
        SetClipboardData(CF_UNICODETEXT, hMem);
        CloseClipboard();

        return true;
    }

    // Save code to file with save dialog
    static bool saveToFile(HWND parent, const std::wstring& code)
    {
        wchar_t filename[MAX_PATH] = L"shape.cpp";

        OPENFILENAMEW ofn = {};
        ofn.lStructSize = sizeof(OPENFILENAMEW);
        ofn.hwndOwner = parent;
        ofn.lpstrFilter = L"C++ Source Files (*.cpp)\0*.cpp\0All Files (*.*)\0*.*\0";
        ofn.lpstrFile = filename;
        ofn.nMaxFile = MAX_PATH;
        ofn.lpstrDefExt = L"cpp";
        ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
        ofn.lpstrTitle = L"Save C++ Code";

        if (!GetSaveFileNameW(&ofn))
            return false;

        // Convert wide string to UTF-8 for file writing
        std::string utf8Code = wstringToUtf8(code);

        // Write to file
        std::ofstream file(filename, std::ios::out | std::ios::binary);
        if (!file.is_open())
        {
            MessageBoxW(parent, L"Failed to create file", L"Error", MB_OK | MB_ICONERROR);
            return false;
        }

        // Write UTF-8 BOM (optional, but helps editors detect encoding)
        const unsigned char bom[] = { 0xEF, 0xBB, 0xBF };
        file.write(reinterpret_cast<const char*>(bom), sizeof(bom));

        file.write(utf8Code.c_str(), utf8Code.length());
        file.close();

        return true;
    }

private:
    // Escape special characters in wide string for C++ code
    static std::wstring escapeWstring(const std::wstring& str)
    {
        std::wostringstream escaped;
        for (wchar_t c : str)
        {
            switch (c)
            {
            case L'\\': escaped << L"\\\\"; break;
            case L'"':  escaped << L"\\\""; break;
            case L'\n': escaped << L"\\n"; break;
            case L'\r': escaped << L"\\r"; break;
            case L'\t': escaped << L"\\t"; break;
            default:    escaped << c; break;
            }
        }
        return escaped.str();
    }

    // Format float with reasonable precision
    static std::wstring formatFloat(float value)
    {
        std::wostringstream ss;
        ss << std::fixed << std::setprecision(4) << value;
        std::wstring result = ss.str();

        // Remove trailing zeros after decimal point
        size_t dotPos = result.find(L'.');
        if (dotPos != std::wstring::npos)
        {
            size_t lastNonZero = result.find_last_not_of(L'0');
            if (lastNonZero != std::wstring::npos && lastNonZero > dotPos)
            {
                result = result.substr(0, lastNonZero + 1);
            }
            // Remove trailing dot
            if (result.back() == L'.')
            {
                result += L'0';
            }
        }
        return result;
    }

    // Convert narrow string to wide string
    static std::wstring stringToWstring(const std::string& str)
    {
        if (str.empty())
            return std::wstring();

        int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), nullptr, 0);
        std::wstring result(size, 0);
        MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), &result[0], size);
        return result;
    }

    // Convert wide string to UTF-8 narrow string
    static std::string wstringToUtf8(const std::wstring& wstr)
    {
        if (wstr.empty())
            return std::string();

        int size = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), nullptr, 0, nullptr, nullptr);
        std::string result(size, 0);
        WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), &result[0], size, nullptr, nullptr);
        return result;
    }
};
