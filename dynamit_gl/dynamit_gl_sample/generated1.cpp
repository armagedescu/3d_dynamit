// Generated by Dynamit Designer - Standalone Application
// Shape: Cone 1
// Controls: WASD to move, mouse to look, ESC to exit, N to toggle normals

#define _USE_MATH_DEFINES
#include <cmath>
#include <vector>
#include <cstdint>
#include <array>
#include <memory>

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <builders.h>
#include <Dynamit.h>
#include <Camera.h>

using namespace dynamit;
using namespace dynamit::builders;

// Global state
Camera g_camera(glm::vec3(0.0f, 0.0f, 3.0f));
float g_lastX = 512.0f, g_lastY = 384.0f;
bool g_firstMouse = true;
bool g_showNormals = false;

void mouseCallback(GLFWwindow* window, double xpos, double ypos)
{
    if (g_firstMouse)
    {
        g_lastX = static_cast<float>(xpos);
        g_lastY = static_cast<float>(ypos);
        g_firstMouse = false;
    }
    float xOffset = static_cast<float>(xpos) - g_lastX;
    float yOffset = g_lastY - static_cast<float>(ypos);
    g_lastX = static_cast<float>(xpos);
    g_lastY = static_cast<float>(ypos);
    g_camera.onMouseMove(xOffset, yOffset);
}

void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (action == GLFW_PRESS)
    {
        if (key == GLFW_KEY_ESCAPE)
            glfwSetWindowShouldClose(window, GLFW_TRUE);
        else if (key == GLFW_KEY_N)
            g_showNormals = !g_showNormals;
    }
}

void processInput(GLFWwindow* window, float deltaTime)
{
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        g_camera.onKeyboard(Camera::Movement::FORWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        g_camera.onKeyboard(Camera::Movement::BACKWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        g_camera.onKeyboard(Camera::Movement::LEFT, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        g_camera.onKeyboard(Camera::Movement::RIGHT, deltaTime);
}

int main_generated1()
{
    // Initialize GLFW
    if (!glfwInit())
        return -1;

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(1024, 768, "Cone 1", nullptr, nullptr);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);
    glfwSetKeyCallback(window, keyCallback);
    glfwSetCursorPosCallback(window, mouseCallback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    // Initialize GLEW
    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK)
        return -1;

    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1f, 0.1f, 0.15f, 1.0f);

    // Build shape geometry
    PolarBuilder builder = Builder::polar();
    builder.formula(L"1")
        .domain(0.0000f, 6.2832f)
        .sectors(16)
        .slices(8)
        .smooth(true)
        .turbo(true)
        .doubleCoated(false)
        .reversed(false)
        .color({ 0.8f, 0.4f, 0.1f, 1.0000f },
            { 0.4f, 0.2f, 0.8f, 1.0000f });

    std::vector<float> verts, norms, colors;
    std::vector<uint32_t> indices;

    builder.buildConeIndexedWithColor(verts, norms, colors, indices);

    // Setup Dynamit renderer
    Dynamit renderer;
    renderer.withVertices3d(verts)
        .withNormals3d(norms)
        .withColors4d(colors)
        .withIndices(indices)
        .withConstLightDirection({ -0.577f, -0.577f, 0.577f })
        .withTransformMatrix4f("transformMatrix");

    // Create normals highlighter
    auto normalsHighlighter = renderer.createNormalsHighlighter(0.05f);
    normalsHighlighter->build(verts, norms);

    // Render loop
    float lastFrame = 0.0f;
    while (!glfwWindowShouldClose(window))
    {
        // Delta time
        float currentFrame = static_cast<float>(glfwGetTime());
        float deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // Process input
        processInput(window, deltaTime);

        // Clear
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // Calculate matrices
        int width, height;
        glfwGetFramebufferSize(window, &width, &height);
        glViewport(0, 0, width, height);

        glm::mat4 projection = glm::perspective(glm::radians(g_camera.zoom),
            static_cast<float>(width) / static_cast<float>(height),
            0.1f, 100.0f);
        glm::mat4 view = g_camera.view();
        glm::mat4 model = glm::mat4(1.0f);
        glm::mat4 mvp = projection * view * model;

        std::array<float, 16> mvpArray;
        memcpy(mvpArray.data(), glm::value_ptr(mvp), sizeof(float) * 16);

        // Render shape
        renderer.transformMatrix4f(mvpArray);
        renderer.drawTrianglesIndexed();

        // Render normals if enabled (press N to toggle)
        if (g_showNormals)
            normalsHighlighter->draw(mvpArray);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}

#include "enabler.h"
#ifdef __GENERATED1_CPP__
int main() { return main_generated1(); }
#endif